using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace IconSource.Avalonia;

internal class IconSet
{
	public string Name { get; }
	public string CodePointFile { get; }
	public string ResourceKey { get; }

	public IconSet(string name, string codePointFile, string resourceKey)
	{
		Name = name;
		CodePointFile = codePointFile;
		ResourceKey = resourceKey;
	}
}

[Generator]
public class IconSourceGenerator : IIncrementalGenerator
{
	private const string IconSourceAttributeCode =
		"""
		// <auto-generated/>
		namespace IconSource
		{
		    [System.AttributeUsage(System.AttributeTargets.Assembly)]
		    public class IconSourceAttribute : System.Attribute
		    {
		        public IconSourceAttribute(string iconSetName, string codePointFileName, string resourceKey) { }
		    }
		}
		""";
	
	private const string IconCode =
		"""
		// <auto-generated/>
		using Avalonia.Controls;

		namespace IconSource
		{		
		    public class Icon : TextBlock
			{
				private IconName _iconName;
				public IconName IconName
				{ 
					get => _iconName;
					set
					{
						_iconName = value;
						Avalonia.Application.Current.TryGetResource(_iconName.resourceKey, out var fontFamily);
						this.FontFamily = fontFamily as Avalonia.Media.FontFamily;
						this.Text = _iconName.codePoint;
					}
				}		
			}
		}
		""";
	
	private const string IconNameCode = 
		"""
		// <auto-generated/>
		namespace IconSource
		{
			public struct IconName
			{
				public string resourceKey;
				public string codePoint;
			}
		}
		""";

	private static readonly Func<string, string, IDictionary<string, string>, string> IconSetCodeGenerator = (iconSet, resourceKey, mapping)=>
		$$"""
		// <auto-generated/>
		namespace IconSource
		{
			public static class {{iconSet}}
			{
				{{string.Join("\n\t\t", mapping.Select(m => $$"""public static readonly IconName {{m.Key}} = new IconName { resourceKey = "{{resourceKey}}", codePoint = "\u{{m.Value}}" };"""))}}
			}
		}
		""";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IconSourceAttribute.g.cs",
			SourceText.From(IconSourceAttributeCode, Encoding.UTF8)));
		
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IconName.g.cs",
			SourceText.From(IconNameCode, Encoding.UTF8)));
		
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"Icon.g.cs",
			SourceText.From(IconCode, Encoding.UTF8)));
		
		// Add generation for icon sources
		var generationBases = context.CompilationProvider
			.Select((c, _) => c.Assembly)
			.SelectMany((s, _) => s.GetAttributes()
				.Where(a => a.AttributeClass?.Name.Equals("IconSourceAttribute") ?? false))
			.Collect()
			.Combine(context.AdditionalTextsProvider.Where(a => a.Path.EndsWith(".codepoints")).Collect());
		
		context.RegisterSourceOutput(generationBases, (productionContext, generationBase) =>
		{
			var (attributes, additionalTextFiles) = (generationBase.Left, generationBase.Right);

			var iconSets = attributes.Select(a => new IconSet(
				(string)a.ConstructorArguments[0].Value!,
				(string)a.ConstructorArguments[1].Value!,
				(string)a.ConstructorArguments[2].Value!));
			
			foreach (var iconSet in iconSets)
			{
				var codePointFile = additionalTextFiles.Single(a => a.Path.EndsWith(iconSet.CodePointFile));
				var mapping = IconSource.GenerateCodePointMapping(codePointFile.GetText().Lines.Select(l => l.ToString()));
				
				productionContext.AddSource(
					$"{iconSet.Name}.g.cs", 
					SourceText.From(IconSetCodeGenerator(iconSet.Name, iconSet.ResourceKey, mapping), Encoding.UTF8));
			}
		});
	}
}
