using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace IconSource.Blazor;

internal class IconSet
{
	public string Name { get; }
	public string CodePointFile { get; }
	public string CssClass { get; }

	public IconSet(string name, string codePointFile, string cssClass)
	{
		Name = name;
		CodePointFile = codePointFile;
		CssClass = cssClass;
	}
}

[Generator]
public class IconSourceGenerator : IIncrementalGenerator
{
	private const string IconSourceAttributeCode =
		"""
		// <auto-generated/>
		namespace IconSource
		{
		    [System.AttributeUsage(System.AttributeTargets.Assembly)]
		    public class IconSourceAttribute : System.Attribute
		    {
		        public IconSourceAttribute(string iconSetName, string codePointFileName, string cssClass) { }
		    }
		}
		""";
	
	private const string IconCode =
		"""
		// <auto-generated/>
		using Microsoft.AspNetCore.Components;

		namespace IconSource
		{
		    public class Icon : IComponent
			{
				private RenderHandle? _renderHandle;
										
				[Parameter]
				public IconName? Name { get; set; }
				
				public void Attach(RenderHandle renderHandle) => 
					_renderHandle = renderHandle;
						
				public Task SetParametersAsync(ParameterView parameters)
				{
					parameters.SetParameterProperties(this);
					_renderHandle?.Render(builder =>
					{
						var seqi = 0;
						builder.Clear();
						builder.OpenElement(seqi++, "span");
						builder.AddAttribute(seqi++, "class", Name?.cssClass);
						builder.AddMarkupContent(seqi, $"&#x{Name?.codePoint};");
						builder.CloseElement();
					});
					return Task.CompletedTask;
				}
			}
		}
		""";
	
	private const string IconNameCode = 
		"""
		// <auto-generated/>
		namespace IconSource
		{
			public struct IconName
			{
				public string cssClass;
				public string codePoint;
			}
		}
		""";

	private static readonly Func<string, string, IDictionary<string, string>, string> IconSetCodeGenerator = (iconSet, cssClass, mapping)=>
		$$"""
		// <auto-generated/>
		namespace IconSource
		{
			public static class {{iconSet}}
			{
				{{string.Join("\n", mapping.Select(m => $$"""public static readonly IconName {{m.Key}} = new IconName { cssClass = "{{cssClass}}", codePoint = "{{m.Value}}" };"""))}}
			}
		}
		""";
	
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IconSourceAttribute.g.cs",
			SourceText.From(IconSourceAttributeCode, Encoding.UTF8)));
		
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"IconName.g.cs",
			SourceText.From(IconNameCode, Encoding.UTF8)));
		
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"Icon.g.cs",
			SourceText.From(IconCode, Encoding.UTF8)));
		
		// Add generation for icon sources
		var generationBases = context.CompilationProvider
			.Select((c, _) => c.Assembly)
			.SelectMany((s, _) => s.GetAttributes()
				.Where(a => a.AttributeClass?.Name.Equals("IconSourceAttribute") ?? false))
			.Collect()
			.Combine(context.AdditionalTextsProvider.Where(a => a.Path.EndsWith(".codepoints")).Collect());
		
		context.RegisterSourceOutput(generationBases, (productionContext, generationBase) =>
		{
			var (attributes, additionalTextFiles) = (generationBase.Left, generationBase.Right);

			var iconSets = attributes.Select(a => new IconSet(
				(string)a.ConstructorArguments[0].Value!,
				(string)a.ConstructorArguments[1].Value!,
				(string)a.ConstructorArguments[2].Value!));
			
			foreach (var iconSet in iconSets)
			{
				var codePointFile = additionalTextFiles.Single(a => a.Path.EndsWith(iconSet.CodePointFile));
				var mapping = IconSource.GenerateCodePointMapping(codePointFile.GetText().Lines.Select(l => l.ToString()));
				
				productionContext.AddSource(
					$"{iconSet.Name}.g.cs", 
					SourceText.From(IconSetCodeGenerator(iconSet.Name, iconSet.CssClass, mapping), Encoding.UTF8));
			}
		});
	}
}
